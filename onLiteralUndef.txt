onLiteralUndef
	
	//gestione joinTuples
	if(tuple.getPredicateName() == &_c){

			//nuovo valore indefinito per c

			//cerco tutte le joinTuples vere che metchano la tupla indefinita di c
            const std::vector<const Tuple* >* trueJoinTuples = &p_c_Y_Z_d_Z_X_0_1_.getValues({tuple[0],tuple[1]});

            for(int i=0;i<trueJoinTuples->size();i++){
            	
            	//elimino la joinTuple dalle vere
                wc_Y_Z_d_Z_X_.erase(*trueJoinTuples->at(i));

                //aggiungo la joinTuple alle indefinite
                uc_Y_Z_d_Z_X_.insert(Tuple(*trueJoinTuples->at(i)));
            }

            //fisso i valori della nuova tupla 
            int Y = tuple.at(0);
            int Z = tuple.at(1);

            //costruisco il join con le altre tuple indefinite di d
            const std::vector<const Tuple*>* tuples1 = &ud_0_.getValues({Z});

            for(int i1=0;i1<tuples1->size();i1++){
                int X = tuples1->at(i1)->at(1);

                //ho un valore per tutte le variabili della joinTuple
                
                std::string predicateName ="c_Y_Z_d_Z_X_";

                //salvo la joinTuple in quelle indefinite
                uc_Y_Z_d_Z_X_.insert(Tuple(&predicateName,std::vector<int>({Y,Z,Z,X})));
            }
        }
    }

    // seguo lo stesso procedimento per d cambiando il joinOrder
